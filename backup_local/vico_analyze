import argparse
import librosa
import numpy as np

def analyze(path, top_n):
    print(f"ğŸ§ Datei: {path}")
    y, sr = librosa.load(path, sr=None, mono=True)
    duration = librosa.get_duration(y=y, sr=sr)

    # === LautstÃ¤rke (RMS) ===
    rms = librosa.feature.rms(y=y)[0]
    rms_times = librosa.frames_to_time(np.arange(len(rms)), sr=sr)
    top_rms = sorted(zip(rms, rms_times), reverse=True)[:top_n]

    # === STFT fÃ¼r Frequenzanalyse ===
    S = np.abs(librosa.stft(y, n_fft=2048, hop_length=512))
    freqs = librosa.fft_frequencies(sr=sr)
    times = librosa.frames_to_time(np.arange(S.shape[1]), sr=sr)

    low_mask = freqs < 200
    high_mask = freqs > 3000

    # === Tiefe TÃ¶ne ===
    lows = [np.sum(S[low_mask, i]) for i in range(S.shape[1])]
    top_lows = sorted(zip(lows, times), reverse=True)[:top_n]

    # === Hohe TÃ¶ne ===
    highs = [np.sum(S[high_mask, i]) for i in range(S.shape[1])]
    top_highs = sorted(zip(highs, times), reverse=True)[:top_n]

    # === Rhythmus / Onsets ===
    onsets = librosa.onset.onset_detect(y=y, sr=sr, units='time')
    top_beats = list(onsets[:top_n])  # einfach die ersten X Wechsel

    # === Ausgabe ===
    print("\nğŸ”Š Pegel - Sekunde")
    for val, t in top_rms:
        print(f"{val:.4f} - {t:.2f}s")

    print("\nğŸ“£ HÃ¶hen - Sekunde")
    for val, t in top_highs:
        print(f"{val:.2f} - {t:.2f}s")

    print("\nğŸšï¸ Tiefen - Sekunde")
    for val, t in top_lows:
        print(f"{val:.2f} - {t:.2f}s")

    print("\nğŸ¥ Beat - Sekunde")
    for t in top_beats:
        print(f"{t:.2f}s")

    print(f"\nâ±ï¸ Ende - Sekunde\n{duration:.2f}s")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Audioanalyse: Pegel, HÃ¶hen, Tiefen, Beats, Dauer")
    parser.add_argument("--input", required=True, help="Pfad zur Audio-Datei (.wav oder .mp3)")
    parser.add_argument("-n", "--top", type=int, default=10, help="Anzahl der Top-Werte pro Kategorie (Default: 10)")
    args = parser.parse_args()

    analyze(args.input, args.top)
